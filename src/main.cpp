#include <iostream>
#include <filesystem>
#include <string>
#include <vector>
#include "yara.h"

#include "path.hpp"
#include "rules_compiler.hpp"

using std::vector, std::string;

void setupCategories() {
    if (!std::filesystem::exists(BLANK_PATH))
        std::filesystem::create_directory(BLANK_PATH);
    if (!std::filesystem::exists(THIEFCAT_PATH))
        std::filesystem::create_directory(THIEFCAT_PATH);
    if (!std::filesystem::exists(EMPYREAN_PATH))
        std::filesystem::create_directory(EMPYREAN_PATH);
    if (!std::filesystem::exists(NOVA_PATH))
        std::filesystem::create_directory(NOVA_PATH);
    if (!std::filesystem::exists(CREAL_PATH))
        std::filesystem::create_directory(CREAL_PATH);
    if (!std::filesystem::exists(BEN_PATH))
        std::filesystem::create_directory(BEN_PATH);
    if (!std::filesystem::exists(UNKNOWN_PATH))
        std::filesystem::create_directory(UNKNOWN_PATH);
}

Malware MatchMalware(const char* rule, const char* file_path) {
    YR_COMPILER *compiler;
    YR_RULES *rules;
    int compiler_status;
    int rules_status;
    compiler_status = yr_compiler_create(&compiler);
    if (compiler_status != ERROR_SUCCESS) {
        throw YaraException("Failed to create compiler");
    }
    rules_status = yr_compiler_add_string(compiler, rule, nullptr);
    if (rules_status != ERROR_SUCCESS) {
        throw YaraException("Failed to add string");
    }
    rules_status = yr_compiler_get_rules(compiler, &rules);
    if (rules_status != ERROR_SUCCESS) {
        throw YaraException("Failed to get rules");
    }
    rules_status = yr_rules_scan_file(rules, file_path, 0, nullptr, nullptr, 10);
    if (rules_status != ERROR_SUCCESS) {
        throw YaraException("Failed to scan file");
    }
    YR_RULE *yrule;
    yr_rules_foreach(rules, yrule) {
        if (yrule->identifier == std::string{"thiefcat"}) {
            return THIEFCAT;
        } else if (yrule->identifier == std::string{"empyrean"}) {
            return EMPYREAN;
        } else if (yrule->identifier == std::string{"nova"}) {
            return NOVA;
        } else if (yrule->identifier == std::string{"creal"}) {
            return CREAL;
        } else if (yrule->identifier == std::string{"ben"}) {
            return BEN;
        } else if (yrule->identifier == std::string{"unknown"}) {
            return UNKNOWN;
        } else if (yrule->identifier == std::string{"blank"}) {
            return BLANK;
        }
    }
}

int main() {
    setupCategories();
    for (const auto &entry : std::filesystem::directory_iterator("D:\\virous\\")) {
        if (entry.is_directory()) continue;
        if (entry.path().extension() == ".exe" || entry.path().extension() == ".dll") {
            string file_path = entry.path().string();
            const char *c_file_path = file_path.c_str();
            const char *c_thiefcat_path = THIEFCAT_PATH;
            const char *c_empyrean_path = EMPYREAN_PATH;
            const char *c_nova_path = NOVA_PATH;
            const char *c_creal_path = CREAL_PATH;
            const char *c_ben_path = BEN_PATH;
            const char *c_unknown_path = UNKNOWN_PATH;
            const char *c_blank_path = BLANK_PATH;
            vector<const char *> rulesstr = RULES();
            for (const auto &rule : rulesstr) {
                Malware malware = MatchMalware(rule, c_file_path);
                const char* dest_folder;
                switch (malware) {
                    case THIEFCAT:
                        dest_folder = c_thiefcat_path;
                        break;
                    case EMPYREAN:
                        dest_folder = c_empyrean_path;
                        break;
                    case NOVA:
                        dest_folder = c_nova_path;
                        break;
                    case CREAL:
                        dest_folder = c_creal_path;
                        break;
                    case BEN:
                        dest_folder = c_ben_path;
                        break;
                    case UNKNOWN:
                        dest_folder = c_unknown_path;
                        break;
                    case BLANK:
                        dest_folder = c_blank_path;
                        break;
                }
                std::filesystem::copy_file(c_file_path, dest_folder + entry.path().filename().string());
            }
        }
    }
    return 0;
}
